# 设計文檔：页面性能優化

## Context

当前係統存在以下性能問題：
1. 页面加载慢：Dashboard、Questions 等页面首次加载需要 3-5 秒
2. 页面刷新失敗：部分页面刷新後无法加载數據
3. 缺乏性能监控：无法識別性能瓶颈
4. 文檔和测試缺失：代碼变更後没有及時更新

## Goals / Non-Goals

**Goals:**
- 页面首次加载時間 < 1 秒（本地环境）
- 所有页面刷新後能正常加载
- API 响应時間 < 500ms（简单查询）
- 建立文檔和测試規范，確保後续变更可維护

**Non-Goals:**
- 引入复杂的性能监控工具（如 APM）
- 实现分布式缓存（如 Redis）
- 重写整个前端架构
- 实现服務端渲染（SSR）

## Decisions

### 决策 1：前端请求優化策略

**選擇：并行请求 + 请求去重 + 简单缓存**

原因：
- 并行请求可以显著减少總加载時間
- 请求去重避免重复请求浪费資源
- 简单缓存（內存缓存，5 分鐘 TTL）可以提升重复访問性能
- 实现简单，无需引入复杂庫

替代方案：
- 使用 React Query：功能强大但增加依赖和學習成本
- 使用 SWR：類似 React Query，但当前需求不需要

### 决策 2：後端查询優化策略

**選擇：索引優化 + 查询缓存 + 性能日志**

原因：
- 索引優化是最直接有效的性能提升方式
- 查询缓存（內存缓存）可以显著减少重复查询
- 性能日志帮助識別慢查询

替代方案：
- 使用 Redis 缓存：功能强大但增加部署复杂度
- 使用數據庫查询缓存：MySQL 查询缓存已废弃

### 决策 3：JSON 字段解析優化

**選擇：在數據庫访問层統一解析，避免在路由层重复解析**

原因：
- 减少重复代碼
- 統一错误处理
- 便于後续優化（如缓存解析結果）

### 决策 4：文檔和测試規范

**選擇：建立轻量级規范，通過检查清单確保执行**

原因：
- 不需要引入复杂的文檔工具
- 检查清单简单易用
- 可以在代碼审查時检查

## Risks / Trade-offs

### 風险 1：缓存可能導致數據不一致

**缓解措施：**
- 使用较短的 TTL（5 分鐘）
- 關键操作（創建、更新、删除）後清除相關缓存
- 提供手動刷新缓存的机制

### 風险 2：性能優化可能引入 bug

**缓解措施：**
- 逐步優化，每次優化後進行测試
- 保留原有代碼邏輯，只優化性能
- 添加性能测試確保優化有效

### 風险 3：文檔和测試規范可能不被遵守

**缓解措施：**
- 在代碼审查時检查文檔和测試
- 提供模板和示例
- 定期审查和更新規范

## Migration Plan

### 阶段 1：诊断和修复（優先级最高）
1. 诊断性能問題
2. 修复页面刷新問題
3. 優化最慢的 API 端點

### 阶段 2：前端優化
1. 優化 API 请求策略
2. 添加 React 性能優化
3. 实现请求缓存

### 阶段 3：後端優化
1. 添加數據庫索引
2. 優化查询邏輯
3. 实现查询缓存

### 阶段 4：規范和文檔
1. 建立文檔規范
2. 建立测試規范
3. 更新相關文檔

## Open Questions

- [ ] 是否需要为不同环境（開發、生产）设置不同的缓存策略？
- [ ] 性能日志是否需要持久化存储？
- [ ] 测試覆盖率要求是否合理（60%）？
