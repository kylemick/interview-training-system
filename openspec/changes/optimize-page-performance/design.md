# 设计文档：页面性能优化

## Context

当前系统存在以下性能问题：
1. 页面加载慢：Dashboard、Questions 等页面首次加载需要 3-5 秒
2. 页面刷新失败：部分页面刷新后无法加载数据
3. 缺乏性能监控：无法识别性能瓶颈
4. 文档和测试缺失：代码变更后没有及时更新

## Goals / Non-Goals

**Goals:**
- 页面首次加载时间 < 1 秒（本地环境）
- 所有页面刷新后能正常加载
- API 响应时间 < 500ms（简单查询）
- 建立文档和测试规范，确保后续变更可维护

**Non-Goals:**
- 引入复杂的性能监控工具（如 APM）
- 实现分布式缓存（如 Redis）
- 重写整个前端架构
- 实现服务端渲染（SSR）

## Decisions

### 决策 1：前端请求优化策略

**选择：并行请求 + 请求去重 + 简单缓存**

原因：
- 并行请求可以显著减少总加载时间
- 请求去重避免重复请求浪费资源
- 简单缓存（内存缓存，5 分钟 TTL）可以提升重复访问性能
- 实现简单，无需引入复杂库

替代方案：
- 使用 React Query：功能强大但增加依赖和学习成本
- 使用 SWR：类似 React Query，但当前需求不需要

### 决策 2：后端查询优化策略

**选择：索引优化 + 查询缓存 + 性能日志**

原因：
- 索引优化是最直接有效的性能提升方式
- 查询缓存（内存缓存）可以显著减少重复查询
- 性能日志帮助识别慢查询

替代方案：
- 使用 Redis 缓存：功能强大但增加部署复杂度
- 使用数据库查询缓存：MySQL 查询缓存已废弃

### 决策 3：JSON 字段解析优化

**选择：在数据库访问层统一解析，避免在路由层重复解析**

原因：
- 减少重复代码
- 统一错误处理
- 便于后续优化（如缓存解析结果）

### 决策 4：文档和测试规范

**选择：建立轻量级规范，通过检查清单确保执行**

原因：
- 不需要引入复杂的文档工具
- 检查清单简单易用
- 可以在代码审查时检查

## Risks / Trade-offs

### 风险 1：缓存可能导致数据不一致

**缓解措施：**
- 使用较短的 TTL（5 分钟）
- 关键操作（创建、更新、删除）后清除相关缓存
- 提供手动刷新缓存的机制

### 风险 2：性能优化可能引入 bug

**缓解措施：**
- 逐步优化，每次优化后进行测试
- 保留原有代码逻辑，只优化性能
- 添加性能测试确保优化有效

### 风险 3：文档和测试规范可能不被遵守

**缓解措施：**
- 在代码审查时检查文档和测试
- 提供模板和示例
- 定期审查和更新规范

## Migration Plan

### 阶段 1：诊断和修复（优先级最高）
1. 诊断性能问题
2. 修复页面刷新问题
3. 优化最慢的 API 端点

### 阶段 2：前端优化
1. 优化 API 请求策略
2. 添加 React 性能优化
3. 实现请求缓存

### 阶段 3：后端优化
1. 添加数据库索引
2. 优化查询逻辑
3. 实现查询缓存

### 阶段 4：规范和文档
1. 建立文档规范
2. 建立测试规范
3. 更新相关文档

## Open Questions

- [ ] 是否需要为不同环境（开发、生产）设置不同的缓存策略？
- [ ] 性能日志是否需要持久化存储？
- [ ] 测试覆盖率要求是否合理（60%）？
